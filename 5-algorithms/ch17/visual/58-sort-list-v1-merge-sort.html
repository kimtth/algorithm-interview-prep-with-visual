<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sort List - Merge Sort</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Segoe UI', sans-serif; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); min-height: 100vh; padding: 20px; }
        .container { max-width: 1200px; margin: 0 auto; }
        h1 { text-align: center; color: white; margin-bottom: 10px; text-shadow: 2px 2px 4px rgba(0,0,0,0.3); }
        .subtitle { text-align: center; color: rgba(255,255,255,0.9); margin-bottom: 20px; font-size: 14px; }
        .controls { display: flex; justify-content: center; gap: 15px; margin-bottom: 20px; flex-wrap: wrap; }
        button { background: white; color: #667eea; border: none; padding: 10px 25px; border-radius: 25px; cursor: pointer; font-weight: 600; transition: all 0.3s; }
        button:hover { transform: scale(1.05); box-shadow: 0 5px 20px rgba(0,0,0,0.2); }
        button:disabled { opacity: 0.5; cursor: not-allowed; transform: none; }
        .panel { background: white; border-radius: 15px; padding: 20px; margin-bottom: 20px; box-shadow: 0 10px 30px rgba(0,0,0,0.2); }
        .panel-title { font-size: 16px; font-weight: bold; color: #333; margin-bottom: 15px; padding-bottom: 10px; border-bottom: 2px solid #667eea; }
        #list-svg { width: 100%; height: 150px; }
        #tree-svg { width: 100%; height: 350px; }
        .node rect { rx: 5; ry: 5; }
        .node text { font-size: 12px; fill: #333; }
        .link { fill: none; stroke: #ccc; stroke-width: 2; }
        .status-box { background: #f5f7fa; border-radius: 10px; padding: 15px; font-family: monospace; }
        .list-node { cursor: pointer; }
        .list-node rect { fill: #f5f7fa; stroke: #667eea; stroke-width: 2; }
        .list-node.active rect { fill: #667eea; stroke: #764ba2; }
        .list-node.slow rect { fill: #4caf50; stroke: #2e7d32; }
        .list-node.fast rect { fill: #ff9800; stroke: #f57c00; }
        .list-node.merged rect { fill: #e3f2fd; stroke: #2196f3; }
        .list-node.active text { fill: white; }
        .arrow { fill: #667eea; }
        .code-box { background: #1e1e1e; color: #d4d4d4; padding: 15px; border-radius: 10px; font-family: 'Consolas', monospace; font-size: 13px; overflow-x: auto; }
        .code-box .highlight { background: #264f78; display: block; margin: 0 -15px; padding: 0 15px; }
        .legend { display: flex; gap: 20px; justify-content: center; margin-top: 15px; font-size: 12px; flex-wrap: wrap; }
        .legend-item { display: flex; align-items: center; gap: 5px; }
        .legend-color { width: 20px; height: 20px; border-radius: 4px; border: 2px solid; }
    </style>
</head>
<body>
    <div class="container">
        <h1>üîó Sort List - Merge Sort</h1>
        <p class="subtitle">O(n log n) using divide and conquer with runner technique</p>

        <div class="controls">
            <button id="stepBtn">Step</button>
            <button id="autoBtn">Auto Run</button>
            <button id="resetBtn">Reset</button>
        </div>

        <div class="panel">
            <div class="panel-title">üìù Linked List</div>
            <svg id="list-svg"></svg>
            <div class="legend">
                <div class="legend-item"><div class="legend-color" style="background:#f5f7fa;border-color:#667eea;"></div>Node</div>
                <div class="legend-item"><div class="legend-color" style="background:#4caf50;border-color:#2e7d32;"></div>Slow Pointer</div>
                <div class="legend-item"><div class="legend-color" style="background:#ff9800;border-color:#f57c00;"></div>Fast Pointer</div>
                <div class="legend-item"><div class="legend-color" style="background:#e3f2fd;border-color:#2196f3;"></div>Merged</div>
            </div>
        </div>

        <div class="panel">
            <div class="panel-title">üå≥ Recursion Tree</div>
            <svg id="tree-svg"></svg>
        </div>

        <div class="panel">
            <div class="panel-title">üìä Status</div>
            <div class="status-box" id="status">Click "Step" or "Auto Run" to start merge sort</div>
        </div>

        <div class="panel">
            <div class="panel-title">üíª Algorithm</div>
            <div class="code-box" id="code">
<span id="line1">def sortList(head):</span>
<span id="line2">    if not (head and head.next):</span>
<span id="line3">        return head</span>
<span id="line4">    </span>
<span id="line5">    # Runner technique to find middle</span>
<span id="line6">    half, slow, fast = None, head, head</span>
<span id="line7">    while fast and fast.next:</span>
<span id="line8">        half, slow, fast = slow, slow.next, fast.next.next</span>
<span id="line9">    half.next = None  # Split list</span>
<span id="line10">    </span>
<span id="line11">    l1 = sortList(head)   # Sort left half</span>
<span id="line12">    l2 = sortList(slow)   # Sort right half</span>
<span id="line13">    return mergeTwoLists(l1, l2)  # Merge</span>
            </div>
        </div>
    </div>

    <script>
        const initialList = [4, 2, 1, 3, 5, 6];
        let list = [...initialList];
        let step = 0;
        let autoInterval = null;
        let recursionTree = { value: list.join(','), children: [], state: 'pending' };
        let currentNode = recursionTree;
        let stack = [];
        let states = [];

        function generateStates() {
            states = [];
            simulateMergeSort([...initialList], recursionTree);
        }

        function simulateMergeSort(arr, node) {
            if (arr.length <= 1) {
                states.push({
                    type: 'base',
                    node: node,
                    arr: arr,
                    message: `Base case: [${arr.join(',')}] (length <= 1)`
                });
                node.state = 'sorted';
                node.sorted = [...arr];
                return arr;
            }

            states.push({
                type: 'divide',
                node: node,
                arr: arr,
                message: `Divide: [${arr.join(',')}]`
            });

            const mid = Math.floor(arr.length / 2);
            const left = arr.slice(0, mid);
            const right = arr.slice(mid);

            node.children = [
                { value: left.join(','), children: [], state: 'pending' },
                { value: right.join(','), children: [], state: 'pending' }
            ];

            states.push({
                type: 'split',
                node: node,
                left: left,
                right: right,
                message: `Split into [${left.join(',')}] and [${right.join(',')}]`
            });

            const sortedLeft = simulateMergeSort(left, node.children[0]);
            const sortedRight = simulateMergeSort(right, node.children[1]);

            const merged = merge(sortedLeft, sortedRight);
            node.sorted = merged;
            node.state = 'sorted';

            states.push({
                type: 'merge',
                node: node,
                left: sortedLeft,
                right: sortedRight,
                result: merged,
                message: `Merge [${sortedLeft.join(',')}] + [${sortedRight.join(',')}] = [${merged.join(',')}]`
            });

            return merged;
        }

        function merge(left, right) {
            const result = [];
            let i = 0, j = 0;
            while (i < left.length && j < right.length) {
                if (left[i] <= right[j]) {
                    result.push(left[i++]);
                } else {
                    result.push(right[j++]);
                }
            }
            return result.concat(left.slice(i)).concat(right.slice(j));
        }

        function renderList(arr, highlights = {}) {
            const svg = d3.select('#list-svg');
            svg.selectAll('*').remove();
            
            const width = svg.node().getBoundingClientRect().width;
            const nodeWidth = 50;
            const nodeHeight = 35;
            const gap = 20;
            const startX = (width - arr.length * (nodeWidth + gap)) / 2;
            
            const g = svg.append('g').attr('transform', 'translate(0, 50)');

            arr.forEach((val, i) => {
                const x = startX + i * (nodeWidth + gap);
                
                // Arrow
                if (i < arr.length - 1) {
                    g.append('path')
                        .attr('d', `M${x + nodeWidth + 5},${nodeHeight/2} L${x + nodeWidth + gap - 5},${nodeHeight/2}`)
                        .attr('stroke', '#667eea')
                        .attr('stroke-width', 2)
                        .attr('marker-end', 'url(#arrowhead)');
                }

                let nodeClass = 'list-node';
                if (highlights.slow === i) nodeClass += ' slow';
                else if (highlights.fast === i) nodeClass += ' fast';
                else if (highlights.merged && highlights.merged.includes(i)) nodeClass += ' merged';

                const node = g.append('g')
                    .attr('class', nodeClass)
                    .attr('transform', `translate(${x}, 0)`);

                node.append('rect')
                    .attr('width', nodeWidth)
                    .attr('height', nodeHeight);

                node.append('text')
                    .attr('x', nodeWidth / 2)
                    .attr('y', nodeHeight / 2 + 5)
                    .attr('text-anchor', 'middle')
                    .text(val);
            });

            // Arrow marker
            svg.append('defs').append('marker')
                .attr('id', 'arrowhead')
                .attr('viewBox', '0 -5 10 10')
                .attr('refX', 8)
                .attr('refY', 0)
                .attr('markerWidth', 6)
                .attr('markerHeight', 6)
                .attr('orient', 'auto')
                .append('path')
                .attr('d', 'M0,-5L10,0L0,5')
                .attr('fill', '#667eea');
        }

        function renderTree() {
            const svg = d3.select('#tree-svg');
            svg.selectAll('*').remove();
            
            const width = svg.node().getBoundingClientRect().width;
            const height = 350;
            const g = svg.append('g').attr('transform', 'translate(40, 30)');

            const hierarchy = d3.hierarchy(recursionTree);
            const treeLayout = d3.tree().size([width - 80, height - 60]);
            treeLayout(hierarchy);

            // Links
            g.selectAll('.link')
                .data(hierarchy.links())
                .enter()
                .append('path')
                .attr('class', 'link')
                .attr('d', d3.linkVertical().x(d => d.x).y(d => d.y));

            // Nodes
            const nodes = g.selectAll('.node')
                .data(hierarchy.descendants())
                .enter()
                .append('g')
                .attr('class', 'node')
                .attr('transform', d => `translate(${d.x}, ${d.y})`);

            nodes.append('rect')
                .attr('width', d => Math.max(60, d.data.value.length * 10))
                .attr('height', 30)
                .attr('x', d => -Math.max(60, d.data.value.length * 10) / 2)
                .attr('y', -15)
                .attr('fill', d => {
                    if (d.data.state === 'sorted') return '#e8f5e9';
                    if (d.data.state === 'active') return '#fff3e0';
                    return '#f5f7fa';
                })
                .attr('stroke', d => {
                    if (d.data.state === 'sorted') return '#4caf50';
                    if (d.data.state === 'active') return '#ff9800';
                    return '#667eea';
                })
                .attr('stroke-width', 2);

            nodes.append('text')
                .attr('dy', 5)
                .attr('text-anchor', 'middle')
                .text(d => `[${d.data.value}]`);

            // Sorted result
            nodes.filter(d => d.data.sorted && d.data.state === 'sorted')
                .append('text')
                .attr('dy', 25)
                .attr('text-anchor', 'middle')
                .attr('fill', '#4caf50')
                .attr('font-size', '10px')
                .text(d => `‚Üí[${d.data.sorted.join(',')}]`);
        }

        function highlightCode(lineNum) {
            document.querySelectorAll('.code-box span').forEach(span => {
                span.classList.remove('highlight');
            });
            if (lineNum) {
                const line = document.getElementById(`line${lineNum}`);
                if (line) line.classList.add('highlight');
            }
        }

        function executeStep() {
            if (step >= states.length) {
                document.getElementById('status').innerHTML = '‚úÖ Merge Sort Complete! List is sorted.';
                document.getElementById('stepBtn').disabled = true;
                document.getElementById('autoBtn').disabled = true;
                stopAuto();
                return;
            }

            const state = states[step];
            
            if (state.node) {
                state.node.state = 'active';
            }

            switch(state.type) {
                case 'divide':
                    highlightCode(2);
                    renderList(state.arr);
                    break;
                case 'split':
                    highlightCode(8);
                    renderList(state.arr, { slow: state.left.length - 1 });
                    break;
                case 'base':
                    highlightCode(3);
                    renderList(state.arr);
                    break;
                case 'merge':
                    highlightCode(13);
                    state.node.state = 'sorted';
                    renderList(state.result, { merged: state.result.map((_, i) => i) });
                    break;
            }

            document.getElementById('status').innerHTML = state.message;
            renderTree();
            step++;
        }

        function reset() {
            stopAuto();
            list = [...initialList];
            step = 0;
            recursionTree = { value: list.join(','), children: [], state: 'pending' };
            generateStates();
            
            document.getElementById('stepBtn').disabled = false;
            document.getElementById('autoBtn').disabled = false;
            document.getElementById('status').innerHTML = 'Click "Step" or "Auto Run" to start merge sort';
            highlightCode(null);
            renderList(list);
            renderTree();
        }

        function stopAuto() {
            if (autoInterval) {
                clearInterval(autoInterval);
                autoInterval = null;
                document.getElementById('autoBtn').textContent = 'Auto Run';
            }
        }

        document.getElementById('stepBtn').addEventListener('click', () => {
            stopAuto();
            executeStep();
        });

        document.getElementById('autoBtn').addEventListener('click', () => {
            if (autoInterval) {
                stopAuto();
            } else {
                autoInterval = setInterval(executeStep, 800);
                document.getElementById('autoBtn').textContent = '‚è∏ Pause';
            }
        });

        document.getElementById('resetBtn').addEventListener('click', reset);

        // Initialize
        generateStates();
        renderList(list);
        renderTree();
    </script>
</body>
</html>
