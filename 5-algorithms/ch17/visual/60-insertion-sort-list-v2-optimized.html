<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Insertion Sort List - Optimized</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Segoe UI', sans-serif; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); min-height: 100vh; padding: 20px; }
        .container { max-width: 1200px; margin: 0 auto; }
        h1 { text-align: center; color: white; margin-bottom: 10px; text-shadow: 2px 2px 4px rgba(0,0,0,0.3); }
        .subtitle { text-align: center; color: rgba(255,255,255,0.9); margin-bottom: 20px; font-size: 14px; }
        .controls { display: flex; justify-content: center; gap: 15px; margin-bottom: 20px; flex-wrap: wrap; }
        button { background: white; color: #667eea; border: none; padding: 10px 25px; border-radius: 25px; cursor: pointer; font-weight: 600; transition: all 0.3s; }
        button:hover { transform: scale(1.05); box-shadow: 0 5px 20px rgba(0,0,0,0.2); }
        button:disabled { opacity: 0.5; cursor: not-allowed; transform: none; }
        .panel { background: white; border-radius: 15px; padding: 20px; margin-bottom: 20px; box-shadow: 0 10px 30px rgba(0,0,0,0.2); }
        .panel-title { font-size: 16px; font-weight: bold; color: #333; margin-bottom: 15px; padding-bottom: 10px; border-bottom: 2px solid #667eea; }
        #list-svg { width: 100%; height: 120px; }
        .node rect { fill: #f5f7fa; stroke: #667eea; stroke-width: 2; rx: 5; }
        .node.current rect { fill: #ff9800; stroke: #f57c00; }
        .node.comparing rect { fill: #667eea; stroke: #764ba2; }
        .node.sorted rect { fill: #4caf50; stroke: #2e7d32; }
        .node.skip rect { fill: #9c27b0; stroke: #7b1fa2; }
        .node text { font-size: 14px; font-weight: bold; fill: #333; }
        .node.current text, .node.comparing text, .node.sorted text, .node.skip text { fill: white; }
        .status-box { background: #f5f7fa; border-radius: 10px; padding: 15px; font-family: monospace; }
        .legend { display: flex; gap: 20px; justify-content: center; margin-top: 15px; font-size: 12px; flex-wrap: wrap; }
        .legend-item { display: flex; align-items: center; gap: 5px; }
        .legend-color { width: 20px; height: 20px; border-radius: 4px; }
        .optimization-box { background: #e8f5e9; border-left: 4px solid #4caf50; padding: 15px; margin-top: 15px; }
        .code-box { background: #1e1e1e; color: #d4d4d4; padding: 15px; border-radius: 10px; font-family: 'Consolas', monospace; font-size: 13px; }
        .code-box .highlight { background: #264f78; display: block; margin: 0 -15px; padding: 0 15px; }
        .stats { display: flex; gap: 30px; justify-content: center; margin-top: 15px; }
        .stat-item { text-align: center; }
        .stat-value { font-size: 24px; font-weight: bold; color: #667eea; }
        .stat-label { font-size: 12px; color: #666; }
    </style>
</head>
<body>
    <div class="container">
        <h1>üîó Insertion Sort List - Optimized</h1>
        <p class="subtitle">O(n¬≤) worst case, but avoids unnecessary resets when data is partially sorted</p>

        <div class="controls">
            <button id="stepBtn">Step</button>
            <button id="autoBtn">Auto Run</button>
            <button id="resetBtn">Reset</button>
        </div>

        <div class="panel">
            <div class="panel-title">üîó Linked List</div>
            <svg id="list-svg"></svg>
            <div class="legend">
                <div class="legend-item"><div class="legend-color" style="background:#f5f7fa;border:2px solid #667eea;"></div>Unsorted</div>
                <div class="legend-item"><div class="legend-color" style="background:#ff9800;"></div>Current (head)</div>
                <div class="legend-item"><div class="legend-color" style="background:#667eea;"></div>Comparing (cur)</div>
                <div class="legend-item"><div class="legend-color" style="background:#9c27b0;"></div>Skip Reset</div>
                <div class="legend-item"><div class="legend-color" style="background:#4caf50;"></div>Sorted</div>
            </div>
            <div class="stats">
                <div class="stat-item">
                    <div class="stat-value" id="comparisons">0</div>
                    <div class="stat-label">Comparisons</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="resets">0</div>
                    <div class="stat-label">Cur Resets</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="skips">0</div>
                    <div class="stat-label">Resets Skipped</div>
                </div>
            </div>
        </div>

        <div class="panel">
            <div class="panel-title">üìä Status</div>
            <div class="status-box" id="status">Click "Step" or "Auto Run" to start optimized insertion sort</div>
            <div class="optimization-box" id="opt-box" style="display:none;">
                <strong>üöÄ Optimization:</strong> <span id="opt-text"></span>
            </div>
        </div>

        <div class="panel">
            <div class="panel-title">üíª Algorithm (Optimized)</div>
            <div class="code-box" id="code">
<span id="line1">def insertionSortList(head):</span>
<span id="line2">    cur = parent = ListNode(0)</span>
<span id="line3">    while head:</span>
<span id="line4">        while cur.next and cur.next.val < head.val:</span>
<span id="line5">            cur = cur.next</span>
<span id="line6">        cur.next, head.next, head = head, cur.next, head.next</span>
<span id="line7">        # Only reset if needed</span>
<span id="line8">        if head and cur.val > head.val:</span>
<span id="line9">            cur = parent</span>
<span id="line10">    return parent.next</span>
            </div>
        </div>
    </div>

    <script>
        const initialList = [1, 2, 3, 6, 4, 5]; // Partially sorted to show optimization
        let unsorted = [...initialList];
        let sorted = [];
        let curIndex = -1;
        let lastInsertedVal = null;
        let phase = 'find';
        let autoInterval = null;
        let comparisons = 0;
        let resets = 0;
        let skips = 0;
        let skipHighlight = false;

        function renderList() {
            const svg = d3.select('#list-svg');
            svg.selectAll('*').remove();
            
            const width = svg.node().getBoundingClientRect().width;
            const nodeWidth = 50;
            const nodeHeight = 40;
            const gap = 25;
            
            const totalNodes = sorted.length + unsorted.length + 1;
            const startX = (width - totalNodes * (nodeWidth + gap)) / 2;
            
            const g = svg.append('g').attr('transform', 'translate(0, 40)');

            svg.append('defs').append('marker')
                .attr('id', 'arrowhead')
                .attr('viewBox', '0 -5 10 10')
                .attr('refX', 8)
                .attr('refY', 0)
                .attr('markerWidth', 6)
                .attr('markerHeight', 6)
                .attr('orient', 'auto')
                .append('path')
                .attr('d', 'M0,-5L10,0L0,5')
                .attr('fill', '#667eea');

            let x = startX;

            // Dummy node
            const dummyGroup = g.append('g')
                .attr('class', 'node')
                .attr('transform', `translate(${x}, 0)`);
            
            dummyGroup.append('rect')
                .attr('width', nodeWidth)
                .attr('height', nodeHeight)
                .attr('fill', '#e0e0e0')
                .attr('stroke', '#999');
            
            dummyGroup.append('text')
                .attr('x', nodeWidth / 2)
                .attr('y', nodeHeight / 2 + 5)
                .attr('text-anchor', 'middle')
                .attr('fill', '#666')
                .text('0');

            if (curIndex === -1) {
                g.append('text')
                    .attr('x', x + nodeWidth / 2)
                    .attr('y', -10)
                    .attr('text-anchor', 'middle')
                    .attr('font-size', '11px')
                    .attr('fill', '#666')
                    .text('cur‚Üì');
            }

            x += nodeWidth + gap;

            // Sorted portion
            sorted.forEach((val, i) => {
                g.append('path')
                    .attr('d', `M${x - gap + 5},${nodeHeight/2} L${x - 5},${nodeHeight/2}`)
                    .attr('stroke', '#4caf50')
                    .attr('stroke-width', 2)
                    .attr('marker-end', 'url(#arrowhead)');

                let nodeClass = 'node sorted';
                if (i === curIndex) nodeClass = 'node comparing';
                if (skipHighlight && i === curIndex) nodeClass = 'node skip';

                const nodeGroup = g.append('g')
                    .attr('class', nodeClass)
                    .attr('transform', `translate(${x}, 0)`);
                
                nodeGroup.append('rect')
                    .attr('width', nodeWidth)
                    .attr('height', nodeHeight);
                
                nodeGroup.append('text')
                    .attr('x', nodeWidth / 2)
                    .attr('y', nodeHeight / 2 + 5)
                    .attr('text-anchor', 'middle')
                    .text(val);

                if (i === curIndex && curIndex >= 0) {
                    g.append('text')
                        .attr('x', x + nodeWidth / 2)
                        .attr('y', -10)
                        .attr('text-anchor', 'middle')
                        .attr('font-size', '11px')
                        .attr('fill', '#666')
                        .text('cur‚Üì');
                }

                x += nodeWidth + gap;
            });

            // Unsorted portion
            unsorted.forEach((val, i) => {
                if (i > 0 || sorted.length > 0) {
                    g.append('path')
                        .attr('d', `M${x - gap + 5},${nodeHeight/2} L${x - 5},${nodeHeight/2}`)
                        .attr('stroke', '#667eea')
                        .attr('stroke-width', 2)
                        .attr('marker-end', 'url(#arrowhead)');
                }

                let nodeClass = 'node';
                if (i === 0) nodeClass = 'node current';

                const nodeGroup = g.append('g')
                    .attr('class', nodeClass)
                    .attr('transform', `translate(${x}, 0)`);
                
                nodeGroup.append('rect')
                    .attr('width', nodeWidth)
                    .attr('height', nodeHeight);
                
                nodeGroup.append('text')
                    .attr('x', nodeWidth / 2)
                    .attr('y', nodeHeight / 2 + 5)
                    .attr('text-anchor', 'middle')
                    .text(val);

                if (i === 0) {
                    g.append('text')
                        .attr('x', x + nodeWidth / 2)
                        .attr('y', nodeHeight + 20)
                        .attr('text-anchor', 'middle')
                        .attr('font-size', '11px')
                        .attr('fill', '#666')
                        .text('‚Üëhead');
                }

                x += nodeWidth + gap;
            });
        }

        function updateStats() {
            document.getElementById('comparisons').textContent = comparisons;
            document.getElementById('resets').textContent = resets;
            document.getElementById('skips').textContent = skips;
        }

        function highlightCode(lineNum) {
            document.querySelectorAll('.code-box span').forEach(span => {
                span.classList.remove('highlight');
            });
            if (lineNum) {
                const line = document.getElementById(`line${lineNum}`);
                if (line) line.classList.add('highlight');
            }
        }

        function showOptimization(text) {
            document.getElementById('opt-box').style.display = 'block';
            document.getElementById('opt-text').textContent = text;
        }

        function hideOptimization() {
            document.getElementById('opt-box').style.display = 'none';
        }

        function executeStep() {
            skipHighlight = false;
            hideOptimization();

            if (unsorted.length === 0) {
                document.getElementById('status').innerHTML = 
                    `‚úÖ Sort complete! Result: [${sorted.join(', ')}]`;
                document.getElementById('stepBtn').disabled = true;
                document.getElementById('autoBtn').disabled = true;
                highlightCode(10);
                stopAuto();
                return;
            }

            const currentVal = unsorted[0];

            if (phase === 'find') {
                const nextIndex = curIndex + 1;
                
                if (nextIndex < sorted.length && sorted[nextIndex] < currentVal) {
                    curIndex = nextIndex;
                    comparisons++;
                    highlightCode(5);
                    document.getElementById('status').innerHTML = 
                        `cur.next.val (${sorted[nextIndex]}) < head.val (${currentVal}), move cur forward`;
                } else {
                    phase = 'insert';
                    highlightCode(6);
                    document.getElementById('status').innerHTML = 
                        `Insert ${currentVal} after position ${curIndex}`;
                }
            } else if (phase === 'insert') {
                const insertPos = curIndex + 1;
                sorted.splice(insertPos, 0, currentVal);
                lastInsertedVal = currentVal;
                unsorted.shift();
                phase = 'check';
                highlightCode(8);
                
                if (unsorted.length > 0) {
                    document.getElementById('status').innerHTML = 
                        `Inserted ${currentVal}. Check if reset needed: cur.val (${curIndex >= 0 ? sorted[curIndex] : 0}) > head.val (${unsorted[0]})?`;
                } else {
                    document.getElementById('status').innerHTML = 
                        `Inserted ${currentVal}. No more elements.`;
                }
            } else if (phase === 'check') {
                const curVal = curIndex >= 0 ? sorted[curIndex] : 0;
                
                if (unsorted.length > 0 && curVal > unsorted[0]) {
                    // Need to reset
                    curIndex = -1;
                    resets++;
                    highlightCode(9);
                    document.getElementById('status').innerHTML = 
                        `cur.val (${curVal}) > head.val (${unsorted[0]}). Reset cur to parent.`;
                } else if (unsorted.length > 0) {
                    // Skip reset - optimization!
                    skips++;
                    skipHighlight = true;
                    showOptimization(`cur.val (${curVal}) ‚â§ head.val (${unsorted[0]}). No reset needed! Saved ${sorted.length - curIndex - 1} comparisons.`);
                    document.getElementById('status').innerHTML = 
                        `üöÄ Optimization: Skip reset! cur stays at position ${curIndex}`;
                }
                phase = 'find';
            }

            updateStats();
            renderList();
        }

        function reset() {
            stopAuto();
            unsorted = [...initialList];
            sorted = [];
            curIndex = -1;
            lastInsertedVal = null;
            phase = 'find';
            comparisons = 0;
            resets = 0;
            skips = 0;
            skipHighlight = false;
            
            document.getElementById('stepBtn').disabled = false;
            document.getElementById('autoBtn').disabled = false;
            document.getElementById('status').innerHTML = 'Click "Step" or "Auto Run" to start optimized insertion sort';
            hideOptimization();
            highlightCode(null);
            updateStats();
            renderList();
        }

        function stopAuto() {
            if (autoInterval) {
                clearInterval(autoInterval);
                autoInterval = null;
                document.getElementById('autoBtn').textContent = 'Auto Run';
            }
        }

        document.getElementById('stepBtn').addEventListener('click', () => {
            stopAuto();
            executeStep();
        });

        document.getElementById('autoBtn').addEventListener('click', () => {
            if (autoInterval) {
                stopAuto();
            } else {
                autoInterval = setInterval(executeStep, 600);
                document.getElementById('autoBtn').textContent = '‚è∏ Pause';
            }
        });

        document.getElementById('resetBtn').addEventListener('click', reset);

        // Initialize
        updateStats();
        renderList();
    </script>
</body>
</html>
