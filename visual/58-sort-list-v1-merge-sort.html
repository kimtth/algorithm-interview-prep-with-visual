<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sort List - Merge Sort</title>
    <link rel="stylesheet" href="visual.css">
    <script src="https://d3js.org/d3.v7.min.js"></script>
    
</head>
<body>
    <div class="container">
        <h1>ğŸ”— Sort List - Merge Sort</h1>
        <p class="subtitle">O(n log n) using divide and conquer with runner technique</p>

        <div class="controls">
            <button id="stepBtn">Step</button>
            <button id="autoBtn">Auto Run</button>
            <button id="resetBtn">Reset</button>
        </div>

        <div class="panel">
            <div class="panel-title">ğŸ“ Linked List</div>
            <svg id="list-svg"></svg>
            <div class="legend">
                <div class="legend-item"><div class="legend-color bg-white-blue-border-purple"></div>Node</div>
                <div class="legend-item"><div class="legend-color legend-box bg-green-border-green-darker"></div>Slow Pointer</div>
                <div class="legend-item"><div class="legend-color bg-orange-border-orange-deep"></div>Fast Pointer</div>
                <div class="legend-item"><div class="legend-color bg-blue-light-border-blue"></div>Merged</div>
            </div>
        </div>

        <div class="panel">
            <div class="panel-title">ğŸŒ³ Recursion Tree</div>
            <svg id="tree-svg"></svg>
        </div>

        <div class="panel">
            <div class="panel-title">ğŸ“Š Status</div>
            <div class="status-box" id="status">Click "Step" or "Auto Run" to start merge sort</div>
        </div>

        <div class="panel">
            <div class="panel-title">ğŸ’» Algorithm</div>
            <div class="code-box" id="code">
<span id="line1">def sortList(head):</span>
<span id="line2">    if not (head and head.next):</span>
<span id="line3">        return head</span>
<span id="line4">    </span>
<span id="line5">    # Runner technique to find middle</span>
<span id="line6">    half, slow, fast = None, head, head</span>
<span id="line7">    while fast and fast.next:</span>
<span id="line8">        half, slow, fast = slow, slow.next, fast.next.next</span>
<span id="line9">    half.next = None  # Split list</span>
<span id="line10">    </span>
<span id="line11">    l1 = sortList(head)   # Sort left half</span>
<span id="line12">    l2 = sortList(slow)   # Sort right half</span>
<span id="line13">    return mergeTwoLists(l1, l2)  # Merge</span>
            </div>
        </div>
    
        <div class="code-section">
            <h3>ğŸ“„ Python Solution (58-1.py)</h3>
            <pre><span class="comment"># Definition for singly-linked list.</span>
<span class="keyword">class</span> ListNode:
    <span class="keyword">def</span> <span class="function">__init__</span>(<span class="keyword">self</span>, x):
        <span class="keyword">self</span>.val = x
        <span class="keyword">self</span>.next = <span class="keyword">None</span>


<span class="keyword">class</span> Solution:
    <span class="comment"># ë‘ ì •ë ¬ ë¦¬ìŠ¤íŠ¸ ë³‘í•©</span>
    <span class="keyword">def</span> <span class="function">mergeTwoLists</span>(<span class="keyword">self</span>, l1: ListNode, l2: ListNode) -&gt; ListNode:
        <span class="keyword">if</span> l1 <span class="keyword">and</span> l2:
            <span class="keyword">if</span> l1.val &gt; l2.val:
                l1, l2 = l2, l1
            l1.next = <span class="keyword">self</span>.<span class="function">mergeTwoLists</span>(l1.next, l2)

        <span class="keyword">return</span> l1 <span class="keyword">or</span> l2

    <span class="keyword">def</span> <span class="function">sortList</span>(<span class="keyword">self</span>, head: ListNode) -&gt; ListNode:
        <span class="keyword">if</span> <span class="keyword">not</span> (head <span class="keyword">and</span> head.next):
            <span class="keyword">return</span> head

        <span class="comment"># ëŸ°ë„ˆ ê¸°ë²• í™œìš©</span>
        half, slow, fast = <span class="keyword">None</span>, head, head
        <span class="keyword">while</span> fast <span class="keyword">and</span> fast.next:
            half, slow, fast = slow, slow.next, fast.next.next
        half.next = <span class="keyword">None</span>

        <span class="comment"># ë¶„í•  ì¬ê·€ í˜¸ì¶œ</span>
        l1 = <span class="keyword">self</span>.<span class="function">sortList</span>(head)
        l2 = <span class="keyword">self</span>.<span class="function">sortList</span>(slow)

        <span class="keyword">return</span> <span class="keyword">self</span>.<span class="function">mergeTwoLists</span>(l1, l2)</pre>
        </div>

    </div>


    <script>
        const initialList = [4, 2, 1, 3, 5, 6];
        let list = [...initialList];
        let step = 0;
        let autoInterval = null;
        let recursionTree = { value: list.join(','), children: [], state: 'pending' };
        let currentNode = recursionTree;
        let stack = [];
        let states = [];

        function generateStates() {
            states = [];
            simulateMergeSort([...initialList], recursionTree);
        }

        function simulateMergeSort(arr, node) {
            if (arr.length <= 1) {
                states.push({
                    type: 'base',
                    node: node,
                    arr: arr,
                    message: `Base case: [${arr.join(',')}] (length <= 1)`
                });
                node.state = 'sorted';
                node.sorted = [...arr];
                return arr;
            }

            states.push({
                type: 'divide',
                node: node,
                arr: arr,
                message: `Divide: [${arr.join(',')}]`
            });

            const mid = Math.floor(arr.length / 2);
            const left = arr.slice(0, mid);
            const right = arr.slice(mid);

            node.children = [
                { value: left.join(','), children: [], state: 'pending' },
                { value: right.join(','), children: [], state: 'pending' }
            ];

            states.push({
                type: 'split',
                node: node,
                left: left,
                right: right,
                message: `Split into [${left.join(',')}] and [${right.join(',')}]`
            });

            const sortedLeft = simulateMergeSort(left, node.children[0]);
            const sortedRight = simulateMergeSort(right, node.children[1]);

            const merged = merge(sortedLeft, sortedRight);
            node.sorted = merged;
            node.state = 'sorted';

            states.push({
                type: 'merge',
                node: node,
                left: sortedLeft,
                right: sortedRight,
                result: merged,
                message: `Merge [${sortedLeft.join(',')}] + [${sortedRight.join(',')}] = [${merged.join(',')}]`
            });

            return merged;
        }

        function merge(left, right) {
            const result = [];
            let i = 0, j = 0;
            while (i < left.length && j < right.length) {
                if (left[i] <= right[j]) {
                    result.push(left[i++]);
                } else {
                    result.push(right[j++]);
                }
            }
            return result.concat(left.slice(i)).concat(right.slice(j));
        }

        function renderList(arr, highlights = {}) {
            const svg = d3.select('#list-svg');
            svg.selectAll('*').remove();
            
            const width = svg.node().getBoundingClientRect().width;
            const nodeWidth = 50;
            const nodeHeight = 35;
            const gap = 20;
            const startX = (width - arr.length * (nodeWidth + gap)) / 2;
            
            const g = svg.append('g').attr('transform', 'translate(0, 50)');

            arr.forEach((val, i) => {
                const x = startX + i * (nodeWidth + gap);
                
                // Arrow
                if (i < arr.length - 1) {
                    g.append('path')
                        .attr('d', `M${x + nodeWidth + 5},${nodeHeight/2} L${x + nodeWidth + gap - 5},${nodeHeight/2}`)
                        .attr('stroke', '#667eea')
                        .attr('stroke-width', 2)
                        .attr('marker-end', 'url(#arrowhead)');
                }

                let nodeClass = 'list-node';
                if (highlights.slow === i) nodeClass += ' slow';
                else if (highlights.fast === i) nodeClass += ' fast';
                else if (highlights.merged && highlights.merged.includes(i)) nodeClass += ' merged';

                const node = g.append('g')
                    .attr('class', nodeClass)
                    .attr('transform', `translate(${x}, 0)`);

                node.append('rect')
                    .attr('width', nodeWidth)
                    .attr('height', nodeHeight);

                node.append('text')
                    .attr('x', nodeWidth / 2)
                    .attr('y', nodeHeight / 2 + 5)
                    .attr('text-anchor', 'middle')
                    .text(val);
            });

            // Arrow marker
            svg.append('defs').append('marker')
                .attr('id', 'arrowhead')
                .attr('viewBox', '0 -5 10 10')
                .attr('refX', 8)
                .attr('refY', 0)
                .attr('markerWidth', 6)
                .attr('markerHeight', 6)
                .attr('orient', 'auto')
                .append('path')
                .attr('d', 'M0,-5L10,0L0,5')
                .attr('fill', '#667eea');
        }

        function renderTree() {
            const svg = d3.select('#tree-svg');
            svg.selectAll('*').remove();
            
            const width = svg.node().getBoundingClientRect().width;
            const height = 350;
            const g = svg.append('g').attr('transform', 'translate(40, 30)');

            const hierarchy = d3.hierarchy(recursionTree);
            const treeLayout = d3.tree().size([width - 80, height - 60]);
            treeLayout(hierarchy);

            // Links
            g.selectAll('.link')
                .data(hierarchy.links())
                .enter()
                .append('path')
                .attr('class', 'link')
                .attr('d', d3.linkVertical().x(d => d.x).y(d => d.y));

            // Nodes
            const nodes = g.selectAll('.node')
                .data(hierarchy.descendants())
                .enter()
                .append('g')
                .attr('class', 'node')
                .attr('transform', d => `translate(${d.x}, ${d.y})`);

            nodes.append('rect')
                .attr('width', d => Math.max(60, d.data.value.length * 10))
                .attr('height', 30)
                .attr('x', d => -Math.max(60, d.data.value.length * 10) / 2)
                .attr('y', -15)
                .attr('fill', d => {
                    if (d.data.state === 'sorted') return '#e8f5e9';
                    if (d.data.state === 'active') return '#fff3e0';
                    return '#f5f7fa';
                })
                .attr('stroke', d => {
                    if (d.data.state === 'sorted') return '#4caf50';
                    if (d.data.state === 'active') return '#ff9800';
                    return '#667eea';
                })
                .attr('stroke-width', 2);

            nodes.append('text')
                .attr('dy', 5)
                .attr('text-anchor', 'middle')
                .text(d => `[${d.data.value}]`);

            // Sorted result
            nodes.filter(d => d.data.sorted && d.data.state === 'sorted')
                .append('text')
                .attr('dy', 25)
                .attr('text-anchor', 'middle')
                .attr('fill', '#4caf50')
                .attr('font-size', '10px')
                .text(d => `â†’[${d.data.sorted.join(',')}]`);
        }

        function highlightCode(lineNum) {
            document.querySelectorAll('.code-box span').forEach(span => {
                span.classList.remove('highlight');
            });
            if (lineNum) {
                const line = document.getElementById(`line${lineNum}`);
                if (line) line.classList.add('highlight');
            }
        }

        function executeStep() {
            if (step >= states.length) {
                document.getElementById('status').innerHTML = 'âœ… Merge Sort Complete! List is sorted.';
                document.getElementById('stepBtn').disabled = true;
                document.getElementById('autoBtn').disabled = true;
                stopAuto();
                return;
            }

            const state = states[step];
            
            if (state.node) {
                state.node.state = 'active';
            }

            switch(state.type) {
                case 'divide':
                    highlightCode(2);
                    renderList(state.arr);
                    break;
                case 'split':
                    highlightCode(8);
                    renderList(state.arr, { slow: state.left.length - 1 });
                    break;
                case 'base':
                    highlightCode(3);
                    renderList(state.arr);
                    break;
                case 'merge':
                    highlightCode(13);
                    state.node.state = 'sorted';
                    renderList(state.result, { merged: state.result.map((_, i) => i) });
                    break;
            }

            document.getElementById('status').innerHTML = state.message;
            renderTree();
            step++;
        }

        function reset() {
            stopAuto();
            list = [...initialList];
            step = 0;
            recursionTree = { value: list.join(','), children: [], state: 'pending' };
            generateStates();
            
            document.getElementById('stepBtn').disabled = false;
            document.getElementById('autoBtn').disabled = false;
            document.getElementById('status').innerHTML = 'Click "Step" or "Auto Run" to start merge sort';
            highlightCode(null);
            renderList(list);
            renderTree();
        }

        function stopAuto() {
            if (autoInterval) {
                clearInterval(autoInterval);
                autoInterval = null;
                document.getElementById('autoBtn').textContent = 'Auto Run';
            }
        }

        document.getElementById('stepBtn').addEventListener('click', () => {
            stopAuto();
            executeStep();
        });

        document.getElementById('autoBtn').addEventListener('click', () => {
            if (autoInterval) {
                stopAuto();
            } else {
                autoInterval = setInterval(executeStep, 800);
                document.getElementById('autoBtn').textContent = 'â¸ Pause';
            }
        });

        document.getElementById('resetBtn').addEventListener('click', reset);

        // Initialize
        generateStates();
        renderList(list);
        renderTree();
    </script>
</body>
</html>
