<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>K Closest Points to Origin</title>
    <link rel="stylesheet" href="visual.css">
    <script src="https://d3js.org/d3.v7.min.js"></script>
    
</head>
<body>
    <div class="container">
        <h1>üìç K Closest Points to Origin</h1>
        <p class="subtitle">O(n log n) using Min Heap - Find K=2 closest points</p>

        <div class="controls">
            <button id="stepBtn">Step</button>
            <button id="autoBtn">Auto Run</button>
            <button id="resetBtn">Reset</button>
        </div>

        <div class="main-grid">
            <div class="panel">
                <div class="panel-title">üìà Coordinate Plane</div>
                <svg id="graph-svg"></svg>
            </div>

            <div class="panel">
                <div class="panel-title">üî¢ Min Heap (by distance¬≤)</div>
                <div class="heap-container" id="heap"></div>
            </div>

            <div class="panel full-width">
                <div class="panel-title">‚úÖ K Closest Points (K=2)</div>
                <div class="result-container" id="results"></div>
            </div>

            <div class="panel full-width">
                <div class="panel-title">üìä Status</div>
                <div class="status-box" id="status">Click "Step" or "Auto Run" to find K closest points</div>
            </div>
        </div>
    
        <div class="code-section">
            <h3>üìÑ Python Solution (64-1.py)</h3>
            <pre><span class="keyword">import</span> heapq
<span class="keyword">from</span> typing <span class="keyword">import</span> List


<span class="keyword">class</span> Solution:
    <span class="keyword">def</span> <span class="function">kClosest</span>(<span class="keyword">self</span>, points: List[List[int]], K: int) -&gt; List[List[int]]:
        heap = []
        <span class="keyword">for</span> (x, y) <span class="keyword">in</span> points:
            dist = x ** <span class="number">2</span> + y ** <span class="number">2</span>
            heapq.<span class="function">heappush</span>(heap, (dist, x, y))

        result = []
        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="function">range</span>(K):
            (dist, x, y) = heapq.<span class="function">heappop</span>(heap)
            result.<span class="function">append</span>((x, y))
        <span class="keyword">return</span> result</pre>
        </div>

    </div>


    <script>
        const points = [[1, 3], [-2, 2], [5, 8], [0, 1]];
        const K = 2;
        let heap = []; // Min heap: [[dist, x, y], ...]
        let results = [];
        let step = 0;
        let phase = 'push'; // 'push', 'pop'
        let pushIndex = 0;
        let popCount = 0;
        let activePoint = -1;
        let autoInterval = null;

        function calculateDist(point) {
            return point[0] ** 2 + point[1] ** 2;
        }

        function renderGraph() {
            const svg = d3.select('#graph-svg');
            svg.selectAll('*').remove();
            
            const width = svg.node().getBoundingClientRect().width;
            const height = 350;
            const margin = 40;
            
            // Scale
            const allCoords = points.flat();
            const maxCoord = Math.max(...allCoords.map(Math.abs)) + 2;
            const scale = d3.scaleLinear()
                .domain([-maxCoord, maxCoord])
                .range([margin, width - margin]);
            const scaleY = d3.scaleLinear()
                .domain([-maxCoord, maxCoord])
                .range([height - margin, margin]);

            const g = svg.append('g');

            // Grid
            for (let i = -Math.floor(maxCoord); i <= maxCoord; i++) {
                g.append('line')
                    .attr('x1', scale(i)).attr('x2', scale(i))
                    .attr('y1', margin).attr('y2', height - margin)
                    .attr('stroke', '#eee').attr('stroke-width', 1);
                g.append('line')
                    .attr('x1', margin).attr('x2', width - margin)
                    .attr('y1', scaleY(i)).attr('y2', scaleY(i))
                    .attr('stroke', '#eee').attr('stroke-width', 1);
            }

            // Axes
            g.append('line')
                .attr('x1', margin).attr('x2', width - margin)
                .attr('y1', scaleY(0)).attr('y2', scaleY(0))
                .attr('stroke', '#333').attr('stroke-width', 2);
            g.append('line')
                .attr('x1', scale(0)).attr('x2', scale(0))
                .attr('y1', margin).attr('y2', height - margin)
                .attr('stroke', '#333').attr('stroke-width', 2);

            // Origin
            g.append('circle')
                .attr('cx', scale(0)).attr('cy', scaleY(0))
                .attr('r', 6).attr('fill', '#667eea');
            g.append('text')
                .attr('x', scale(0) + 10).attr('y', scaleY(0) + 15)
                .attr('font-size', '12px').attr('fill', '#667eea')
                .text('Origin');

            // Points
            points.forEach((p, i) => {
                const isActive = i === activePoint;
                const isSelected = results.some(r => r[0] === p[0] && r[1] === p[1]);
                const isInHeap = heap.some(h => h[1] === p[0] && h[2] === p[1]);
                
                // Distance line
                if (isActive || isSelected) {
                    g.append('line')
                        .attr('x1', scale(0)).attr('y1', scaleY(0))
                        .attr('x2', scale(p[0])).attr('y2', scaleY(p[1]))
                        .attr('stroke', isSelected ? '#4caf50' : '#ff9800')
                        .attr('stroke-width', 2)
                        .attr('stroke-dasharray', '5,5');
                }

                // Point
                g.append('circle')
                    .attr('class', `point ${isActive ? 'active' : ''} ${isSelected ? 'selected' : ''}`)
                    .attr('cx', scale(p[0])).attr('cy', scaleY(p[1]))
                    .attr('r', isActive ? 12 : 10)
                    .attr('fill', isSelected ? '#4caf50' : (isActive ? '#ff9800' : (isInHeap ? '#667eea' : '#999')));

                // Label
                g.append('text')
                    .attr('x', scale(p[0]) + 12).attr('y', scaleY(p[1]) - 8)
                    .attr('font-size', '12px').attr('font-weight', 'bold')
                    .text(`(${p[0]},${p[1]})`);

                // Distance
                const dist = calculateDist(p);
                g.append('text')
                    .attr('class', 'dist-label')
                    .attr('x', scale(p[0]) + 12).attr('y', scaleY(p[1]) + 8)
                    .text(`d¬≤=${dist}`);
            });
        }

        function renderHeap() {
            const container = document.getElementById('heap');
            if (heap.length === 0) {
                container.innerHTML = '<div class="empty-text">Empty</div>';
                return;
            }
            container.innerHTML = heap.map((item, i) => {
                let cls = 'heap-item';
                if (phase === 'push' && i === heap.length - 1 && activePoint >= 0) cls += ' adding';
                if (phase === 'pop' && i === 0) cls += ' popping';
                return `<div class="${cls}">dist¬≤=${item[0]} ‚Üí (${item[1]},${item[2]})</div>`;
            }).join('');
        }

        function renderResults() {
            const container = document.getElementById('results');
            container.innerHTML = results.map(p => 
                `<div class="result-item">(${p[0]}, ${p[1]})</div>`
            ).join('');
        }

        function heapPush(item) {
            heap.push(item);
            // Bubble up
            let i = heap.length - 1;
            while (i > 0) {
                const parent = Math.floor((i - 1) / 2);
                if (heap[parent][0] > heap[i][0]) {
                    [heap[parent], heap[i]] = [heap[i], heap[parent]];
                    i = parent;
                } else break;
            }
        }

        function heapPop() {
            if (heap.length === 0) return null;
            const result = heap[0];
            const last = heap.pop();
            if (heap.length > 0) {
                heap[0] = last;
                // Bubble down
                let i = 0;
                while (true) {
                    const left = 2 * i + 1;
                    const right = 2 * i + 2;
                    let smallest = i;
                    if (left < heap.length && heap[left][0] < heap[smallest][0]) smallest = left;
                    if (right < heap.length && heap[right][0] < heap[smallest][0]) smallest = right;
                    if (smallest !== i) {
                        [heap[i], heap[smallest]] = [heap[smallest], heap[i]];
                        i = smallest;
                    } else break;
                }
            }
            return result;
        }

        function executeStep() {
            if (phase === 'push') {
                if (pushIndex < points.length) {
                    const p = points[pushIndex];
                    const dist = calculateDist(p);
                    activePoint = pushIndex;
                    
                    heapPush([dist, p[0], p[1]]);
                    
                    document.getElementById('status').innerHTML = 
                        `Push point (${p[0]}, ${p[1]}) with distance¬≤ = ${dist} to min heap`;
                    
                    pushIndex++;
                } else {
                    phase = 'pop';
                    activePoint = -1;
                    document.getElementById('status').innerHTML = 
                        `All points added to heap. Now extract K=${K} closest points.`;
                }
            } else if (phase === 'pop') {
                if (popCount < K && heap.length > 0) {
                    const item = heapPop();
                    results.push([item[1], item[2]]);
                    popCount++;
                    
                    document.getElementById('status').innerHTML = 
                        `Pop closest point: (${item[1]}, ${item[2]}) with distance¬≤ = ${item[0]}`;
                } else {
                    document.getElementById('status').innerHTML = 
                        `‚úÖ Found K=${K} closest points: ${results.map(p => `(${p[0]},${p[1]})`).join(', ')}`;
                    document.getElementById('stepBtn').disabled = true;
                    document.getElementById('autoBtn').disabled = true;
                    stopAuto();
                }
            }

            renderGraph();
            renderHeap();
            renderResults();
        }

        function reset() {
            stopAuto();
            heap = [];
            results = [];
            step = 0;
            phase = 'push';
            pushIndex = 0;
            popCount = 0;
            activePoint = -1;
            
            document.getElementById('stepBtn').disabled = false;
            document.getElementById('autoBtn').disabled = false;
            document.getElementById('status').innerHTML = 'Click "Step" or "Auto Run" to find K closest points';
            
            renderGraph();
            renderHeap();
            renderResults();
        }

        function stopAuto() {
            if (autoInterval) {
                clearInterval(autoInterval);
                autoInterval = null;
                document.getElementById('autoBtn').textContent = 'Auto Run';
            }
        }

        document.getElementById('stepBtn').addEventListener('click', () => {
            stopAuto();
            executeStep();
        });

        document.getElementById('autoBtn').addEventListener('click', () => {
            if (autoInterval) {
                stopAuto();
            } else {
                autoInterval = setInterval(executeStep, 800);
                document.getElementById('autoBtn').textContent = '‚è∏ Pause';
            }
        });

        document.getElementById('resetBtn').addEventListener('click', reset);

        // Initialize
        renderGraph();
        renderHeap();
    </script>
</body>
</html>
