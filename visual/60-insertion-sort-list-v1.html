<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Insertion Sort List - Basic</title>
    <link rel="stylesheet" href="visual.css">
    <script src="https://d3js.org/d3.v7.min.js"></script>
    
</head>
<body>
    <div class="container">
        <h1>üîó Insertion Sort List</h1>
        <p class="subtitle">O(n¬≤) - Insert each node into correct position in sorted portion</p>

        <div class="controls">
            <button id="stepBtn">Step</button>
            <button id="autoBtn">Auto Run</button>
            <button id="resetBtn">Reset</button>
        </div>

        <div class="panel">
            <div class="panel-title">üîó Linked List</div>
            <svg id="list-svg"></svg>
            <div class="legend">
                <div class="legend-item"><div class="legend-color bg-white-blue-border-purple-thick"></div>Unsorted</div>
                <div class="legend-item"><div class="legend-color bg-orange"></div>Current (head)</div>
                <div class="legend-item"><div class="legend-color bg-purple-trie"></div>Comparing (cur)</div>
                <div class="legend-item"><div class="legend-color bg-pink"></div>Insert Position</div>
                <div class="legend-item"><div class="legend-color bg-green"></div>Sorted</div>
            </div>
        </div>

        <div class="panel">
            <div class="panel-title">üìä Status</div>
            <div class="status-box" id="status">Click "Step" or "Auto Run" to start insertion sort</div>
        </div>

        <div class="panel">
            <div class="panel-title">üíª Algorithm</div>
            <div class="code-box" id="code">
<span id="line1">def insertionSortList(head):</span>
<span id="line2">    cur = parent = ListNode(None)  # Dummy node</span>
<span id="line3">    while head:</span>
<span id="line4">        # Find insertion position</span>
<span id="line5">        while cur.next and cur.next.val < head.val:</span>
<span id="line6">            cur = cur.next</span>
<span id="line7">        # Insert node</span>
<span id="line8">        cur.next, head.next, head = head, cur.next, head.next</span>
<span id="line9">        cur = parent  # Reset cur to start</span>
<span id="line10">    return parent.next</span>
            </div>
        </div>
    
        <div class="code-section">
            <h3>üìÑ Python Solution (60-1.py)</h3>
            <pre><span class="comment"># Definition for singly-linked list.</span>
<span class="keyword">class</span> ListNode:
    <span class="keyword">def</span> <span class="function">__init__</span>(<span class="keyword">self</span>, x):
        <span class="keyword">self</span>.val = x
        <span class="keyword">self</span>.next = <span class="keyword">None</span>


<span class="keyword">class</span> Solution:
    <span class="keyword">def</span> <span class="function">insertionSortList</span>(<span class="keyword">self</span>, head: ListNode) -&gt; ListNode:
        cur = parent = <span class="function">ListNode</span>(<span class="keyword">None</span>)
        <span class="keyword">while</span> head:
            <span class="keyword">while</span> cur.next <span class="keyword">and</span> cur.next.val &lt; head.val:
                cur = cur.next

            cur.next, head.next, head = head, cur.next, head.next

            cur = parent
        <span class="keyword">return</span> cur.next</pre>
        </div>

    </div>


    <script>
        const initialList = [4, 2, 1, 3];
        let unsorted = [...initialList];
        let sorted = [];
        let headIndex = 0;
        let curIndex = -1; // -1 means at dummy/parent
        let phase = 'find'; // 'find' or 'insert'
        let autoInterval = null;

        function renderList() {
            const svg = d3.select('#list-svg');
            svg.selectAll('*').remove();
            
            const width = svg.node().getBoundingClientRect().width;
            const nodeWidth = 50;
            const nodeHeight = 40;
            const gap = 25;
            
            // Calculate positions
            const totalNodes = sorted.length + unsorted.length + 1; // +1 for dummy
            const startX = (width - totalNodes * (nodeWidth + gap)) / 2;
            
            const g = svg.append('g').attr('transform', 'translate(0, 40)');

            // Arrow marker
            svg.append('defs').append('marker')
                .attr('id', 'arrowhead')
                .attr('viewBox', '0 -5 10 10')
                .attr('refX', 8)
                .attr('refY', 0)
                .attr('markerWidth', 6)
                .attr('markerHeight', 6)
                .attr('orient', 'auto')
                .append('path')
                .attr('d', 'M0,-5L10,0L0,5')
                .attr('fill', '#667eea');

            let x = startX;

            // Draw dummy node (parent)
            const dummyGroup = g.append('g')
                .attr('class', 'node')
                .attr('transform', `translate(${x}, 0)`);
            
            dummyGroup.append('rect')
                .attr('width', nodeWidth)
                .attr('height', nodeHeight)
                .attr('fill', '#e0e0e0')
                .attr('stroke', '#999');
            
            dummyGroup.append('text')
                .attr('x', nodeWidth / 2)
                .attr('y', nodeHeight / 2 + 5)
                .attr('text-anchor', 'middle')
                .attr('fill', '#666')
                .text('‚àÖ');

            // Pointer label
            if (curIndex === -1) {
                g.append('text')
                    .attr('class', 'pointer-label')
                    .attr('x', x + nodeWidth / 2)
                    .attr('y', -10)
                    .attr('text-anchor', 'middle')
                    .text('cur‚Üì');
            }

            x += nodeWidth + gap;

            // Draw sorted portion
            sorted.forEach((val, i) => {
                // Arrow from previous
                g.append('path')
                    .attr('d', `M${x - gap + 5},${nodeHeight/2} L${x - 5},${nodeHeight/2}`)
                    .attr('stroke', '#4caf50')
                    .attr('stroke-width', 2)
                    .attr('marker-end', 'url(#arrowhead)');

                let nodeClass = 'node sorted';
                if (i === curIndex) nodeClass = 'node comparing';
                if (phase === 'insert' && i === curIndex) nodeClass = 'node inserting';

                const nodeGroup = g.append('g')
                    .attr('class', nodeClass)
                    .attr('transform', `translate(${x}, 0)`);
                
                nodeGroup.append('rect')
                    .attr('width', nodeWidth)
                    .attr('height', nodeHeight);
                
                nodeGroup.append('text')
                    .attr('x', nodeWidth / 2)
                    .attr('y', nodeHeight / 2 + 5)
                    .attr('text-anchor', 'middle')
                    .text(val);

                if (i === curIndex && curIndex >= 0) {
                    g.append('text')
                        .attr('class', 'pointer-label')
                        .attr('x', x + nodeWidth / 2)
                        .attr('y', -10)
                        .attr('text-anchor', 'middle')
                        .text('cur‚Üì');
                }

                x += nodeWidth + gap;
            });

            // Draw unsorted portion
            unsorted.forEach((val, i) => {
                // Arrow
                if (i > 0 || sorted.length > 0) {
                    g.append('path')
                        .attr('d', `M${x - gap + 5},${nodeHeight/2} L${x - 5},${nodeHeight/2}`)
                        .attr('stroke', '#667eea')
                        .attr('stroke-width', 2)
                        .attr('marker-end', 'url(#arrowhead)');
                }

                let nodeClass = 'node';
                if (i === 0) nodeClass = 'node current';

                const nodeGroup = g.append('g')
                    .attr('class', nodeClass)
                    .attr('transform', `translate(${x}, 0)`);
                
                nodeGroup.append('rect')
                    .attr('width', nodeWidth)
                    .attr('height', nodeHeight);
                
                nodeGroup.append('text')
                    .attr('x', nodeWidth / 2)
                    .attr('y', nodeHeight / 2 + 5)
                    .attr('text-anchor', 'middle')
                    .text(val);

                if (i === 0) {
                    g.append('text')
                        .attr('class', 'pointer-label')
                        .attr('x', x + nodeWidth / 2)
                        .attr('y', nodeHeight + 20)
                        .attr('text-anchor', 'middle')
                        .text('‚Üëhead');
                }

                x += nodeWidth + gap;
            });
        }

        function highlightCode(lineNum) {
            document.querySelectorAll('.code-box span').forEach(span => {
                span.classList.remove('highlight');
            });
            if (lineNum) {
                const line = document.getElementById(`line${lineNum}`);
                if (line) line.classList.add('highlight');
            }
        }

        function executeStep() {
            if (unsorted.length === 0) {
                document.getElementById('status').innerHTML = 
                    `‚úÖ Sort complete! Result: [${sorted.join(', ')}]`;
                document.getElementById('stepBtn').disabled = true;
                document.getElementById('autoBtn').disabled = true;
                highlightCode(10);
                stopAuto();
                return;
            }

            const currentVal = unsorted[0];

            if (phase === 'find') {
                // Find insertion position
                const nextIndex = curIndex + 1;
                
                if (nextIndex < sorted.length && sorted[nextIndex] < currentVal) {
                    curIndex = nextIndex;
                    highlightCode(6);
                    document.getElementById('status').innerHTML = 
                        `cur.next.val (${sorted[nextIndex]}) < head.val (${currentVal}), move cur forward`;
                } else {
                    phase = 'insert';
                    highlightCode(8);
                    document.getElementById('status').innerHTML = 
                        `Found position! Insert ${currentVal} after index ${curIndex}`;
                }
            } else {
                // Insert
                const insertPos = curIndex + 1;
                sorted.splice(insertPos, 0, currentVal);
                unsorted.shift();
                
                curIndex = -1;
                phase = 'find';
                highlightCode(9);
                document.getElementById('status').innerHTML = 
                    `Inserted ${currentVal}. Reset cur to parent. Sorted: [${sorted.join(', ')}]`;
            }

            renderList();
        }

        function reset() {
            stopAuto();
            unsorted = [...initialList];
            sorted = [];
            curIndex = -1;
            phase = 'find';
            
            document.getElementById('stepBtn').disabled = false;
            document.getElementById('autoBtn').disabled = false;
            document.getElementById('status').innerHTML = 'Click "Step" or "Auto Run" to start insertion sort';
            highlightCode(null);
            renderList();
        }

        function stopAuto() {
            if (autoInterval) {
                clearInterval(autoInterval);
                autoInterval = null;
                document.getElementById('autoBtn').textContent = 'Auto Run';
            }
        }

        document.getElementById('stepBtn').addEventListener('click', () => {
            stopAuto();
            executeStep();
        });

        document.getElementById('autoBtn').addEventListener('click', () => {
            if (autoInterval) {
                stopAuto();
            } else {
                autoInterval = setInterval(executeStep, 600);
                document.getElementById('autoBtn').textContent = '‚è∏ Pause';
            }
        });

        document.getElementById('resetBtn').addEventListener('click', reset);

        // Initialize
        renderList();
    </script>
</body>
</html>
