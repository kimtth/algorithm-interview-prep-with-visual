<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Insertion Sort List - Optimized</title>
    <link rel="stylesheet" href="visual.css">
    <script src="https://d3js.org/d3.v7.min.js"></script>
    
</head>
<body>
    <div class="container">
        <h1>ğŸ”— Insertion Sort List - Optimized</h1>
        <p class="subtitle">O(nÂ²) worst case, but avoids unnecessary resets when data is partially sorted</p>

        <div class="controls">
            <button id="stepBtn">Step</button>
            <button id="autoBtn">Auto Run</button>
            <button id="resetBtn">Reset</button>
        </div>

        <div class="panel">
            <div class="panel-title">ğŸ”— Linked List</div>
            <svg id="list-svg"></svg>
            <div class="legend">
                <div class="legend-item"><div class="legend-color bg-white-blue-border-purple-thick"></div>Unsorted</div>
                <div class="legend-item"><div class="legend-color bg-orange"></div>Current (head)</div>
                <div class="legend-item"><div class="legend-color bg-purple-trie"></div>Comparing (cur)</div>
                <div class="legend-item"><div class="legend-color bg-purple-deep"></div>Skip Reset</div>
                <div class="legend-item"><div class="legend-color bg-green"></div>Sorted</div>
            </div>
            <div class="stats">
                <div class="stat-item">
                    <div class="stat-value" id="comparisons">0</div>
                    <div class="stat-label">Comparisons</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="resets">0</div>
                    <div class="stat-label">Cur Resets</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="skips">0</div>
                    <div class="stat-label">Resets Skipped</div>
                </div>
            </div>
        </div>

        <div class="panel">
            <div class="panel-title">ğŸ“Š Status</div>
            <div class="status-box" id="status">Click "Step" or "Auto Run" to start optimized insertion sort</div>
            <div class="optimization-box" id="opt-box" class="d-none">
                <strong>ğŸš€ Optimization:</strong> <span id="opt-text"></span>
            </div>
        </div>

        <div class="panel">
            <div class="panel-title">ğŸ’» Algorithm (Optimized)</div>
            <div class="code-box" id="code">
<span id="line1">def insertionSortList(head):</span>
<span id="line2">    cur = parent = ListNode(0)</span>
<span id="line3">    while head:</span>
<span id="line4">        while cur.next and cur.next.val < head.val:</span>
<span id="line5">            cur = cur.next</span>
<span id="line6">        cur.next, head.next, head = head, cur.next, head.next</span>
<span id="line7">        # Only reset if needed</span>
<span id="line8">        if head and cur.val > head.val:</span>
<span id="line9">            cur = parent</span>
<span id="line10">    return parent.next</span>
            </div>
        </div>
    
        <div class="code-section">
            <h3>ğŸ“„ Python Solution (60-2.py)</h3>
            <pre><span class="comment"># Definition for singly-linked list.</span>
<span class="keyword">class</span> ListNode:
    <span class="keyword">def</span> <span class="function">__init__</span>(<span class="keyword">self</span>, x):
        <span class="keyword">self</span>.val = x
        <span class="keyword">self</span>.next = <span class="keyword">None</span>


<span class="keyword">class</span> Solution:
    <span class="keyword">def</span> <span class="function">insertionSortList</span>(<span class="keyword">self</span>, head: ListNode) -&gt; ListNode:
        <span class="comment"># ì´ˆê¸°ê°’ ë³€ê²½</span>
        cur = parent = <span class="function">ListNode</span>(<span class="number">0</span>)
        <span class="keyword">while</span> head:
            <span class="keyword">while</span> cur.next <span class="keyword">and</span> cur.next.val &lt; head.val:
                cur = cur.next

            cur.next, head.next, head = head, cur.next, head.next

            <span class="comment"># í•„ìš”í•œ ê²½ìš°ì—ë§Œ cur í¬ì¸í„°ê°€ ë˜ëŒì•„ê°€ë„ë¡ ì²˜ë¦¬</span>
            <span class="keyword">if</span> head <span class="keyword">and</span> cur.val &gt; head.val:
                cur = parent
        <span class="keyword">return</span> parent.next</pre>
        </div>

    </div>


    <script>
        const initialList = [1, 2, 3, 6, 4, 5]; // Partially sorted to show optimization
        let unsorted = [...initialList];
        let sorted = [];
        let curIndex = -1;
        let lastInsertedVal = null;
        let phase = 'find';
        let autoInterval = null;
        let comparisons = 0;
        let resets = 0;
        let skips = 0;
        let skipHighlight = false;

        function renderList() {
            const svg = d3.select('#list-svg');
            svg.selectAll('*').remove();
            
            const width = svg.node().getBoundingClientRect().width;
            const nodeWidth = 50;
            const nodeHeight = 40;
            const gap = 25;
            
            const totalNodes = sorted.length + unsorted.length + 1;
            const startX = (width - totalNodes * (nodeWidth + gap)) / 2;
            
            const g = svg.append('g').attr('transform', 'translate(0, 40)');

            svg.append('defs').append('marker')
                .attr('id', 'arrowhead')
                .attr('viewBox', '0 -5 10 10')
                .attr('refX', 8)
                .attr('refY', 0)
                .attr('markerWidth', 6)
                .attr('markerHeight', 6)
                .attr('orient', 'auto')
                .append('path')
                .attr('d', 'M0,-5L10,0L0,5')
                .attr('fill', '#667eea');

            let x = startX;

            // Dummy node
            const dummyGroup = g.append('g')
                .attr('class', 'node')
                .attr('transform', `translate(${x}, 0)`);
            
            dummyGroup.append('rect')
                .attr('width', nodeWidth)
                .attr('height', nodeHeight)
                .attr('fill', '#e0e0e0')
                .attr('stroke', '#999');
            
            dummyGroup.append('text')
                .attr('x', nodeWidth / 2)
                .attr('y', nodeHeight / 2 + 5)
                .attr('text-anchor', 'middle')
                .attr('fill', '#666')
                .text('0');

            if (curIndex === -1) {
                g.append('text')
                    .attr('x', x + nodeWidth / 2)
                    .attr('y', -10)
                    .attr('text-anchor', 'middle')
                    .attr('font-size', '11px')
                    .attr('fill', '#666')
                    .text('curâ†“');
            }

            x += nodeWidth + gap;

            // Sorted portion
            sorted.forEach((val, i) => {
                g.append('path')
                    .attr('d', `M${x - gap + 5},${nodeHeight/2} L${x - 5},${nodeHeight/2}`)
                    .attr('stroke', '#4caf50')
                    .attr('stroke-width', 2)
                    .attr('marker-end', 'url(#arrowhead)');

                let nodeClass = 'node sorted';
                if (i === curIndex) nodeClass = 'node comparing';
                if (skipHighlight && i === curIndex) nodeClass = 'node skip';

                const nodeGroup = g.append('g')
                    .attr('class', nodeClass)
                    .attr('transform', `translate(${x}, 0)`);
                
                nodeGroup.append('rect')
                    .attr('width', nodeWidth)
                    .attr('height', nodeHeight);
                
                nodeGroup.append('text')
                    .attr('x', nodeWidth / 2)
                    .attr('y', nodeHeight / 2 + 5)
                    .attr('text-anchor', 'middle')
                    .text(val);

                if (i === curIndex && curIndex >= 0) {
                    g.append('text')
                        .attr('x', x + nodeWidth / 2)
                        .attr('y', -10)
                        .attr('text-anchor', 'middle')
                        .attr('font-size', '11px')
                        .attr('fill', '#666')
                        .text('curâ†“');
                }

                x += nodeWidth + gap;
            });

            // Unsorted portion
            unsorted.forEach((val, i) => {
                if (i > 0 || sorted.length > 0) {
                    g.append('path')
                        .attr('d', `M${x - gap + 5},${nodeHeight/2} L${x - 5},${nodeHeight/2}`)
                        .attr('stroke', '#667eea')
                        .attr('stroke-width', 2)
                        .attr('marker-end', 'url(#arrowhead)');
                }

                let nodeClass = 'node';
                if (i === 0) nodeClass = 'node current';

                const nodeGroup = g.append('g')
                    .attr('class', nodeClass)
                    .attr('transform', `translate(${x}, 0)`);
                
                nodeGroup.append('rect')
                    .attr('width', nodeWidth)
                    .attr('height', nodeHeight);
                
                nodeGroup.append('text')
                    .attr('x', nodeWidth / 2)
                    .attr('y', nodeHeight / 2 + 5)
                    .attr('text-anchor', 'middle')
                    .text(val);

                if (i === 0) {
                    g.append('text')
                        .attr('x', x + nodeWidth / 2)
                        .attr('y', nodeHeight + 20)
                        .attr('text-anchor', 'middle')
                        .attr('font-size', '11px')
                        .attr('fill', '#666')
                        .text('â†‘head');
                }

                x += nodeWidth + gap;
            });
        }

        function updateStats() {
            document.getElementById('comparisons').textContent = comparisons;
            document.getElementById('resets').textContent = resets;
            document.getElementById('skips').textContent = skips;
        }

        function highlightCode(lineNum) {
            document.querySelectorAll('.code-box span').forEach(span => {
                span.classList.remove('highlight');
            });
            if (lineNum) {
                const line = document.getElementById(`line${lineNum}`);
                if (line) line.classList.add('highlight');
            }
        }

        function showOptimization(text) {
            document.getElementById('opt-box').style.display = 'block';
            document.getElementById('opt-text').textContent = text;
        }

        function hideOptimization() {
            document.getElementById('opt-box').style.display = 'none';
        }

        function executeStep() {
            skipHighlight = false;
            hideOptimization();

            if (unsorted.length === 0) {
                document.getElementById('status').innerHTML = 
                    `âœ… Sort complete! Result: [${sorted.join(', ')}]`;
                document.getElementById('stepBtn').disabled = true;
                document.getElementById('autoBtn').disabled = true;
                highlightCode(10);
                stopAuto();
                return;
            }

            const currentVal = unsorted[0];

            if (phase === 'find') {
                const nextIndex = curIndex + 1;
                
                if (nextIndex < sorted.length && sorted[nextIndex] < currentVal) {
                    curIndex = nextIndex;
                    comparisons++;
                    highlightCode(5);
                    document.getElementById('status').innerHTML = 
                        `cur.next.val (${sorted[nextIndex]}) < head.val (${currentVal}), move cur forward`;
                } else {
                    phase = 'insert';
                    highlightCode(6);
                    document.getElementById('status').innerHTML = 
                        `Insert ${currentVal} after position ${curIndex}`;
                }
            } else if (phase === 'insert') {
                const insertPos = curIndex + 1;
                sorted.splice(insertPos, 0, currentVal);
                lastInsertedVal = currentVal;
                unsorted.shift();
                phase = 'check';
                highlightCode(8);
                
                if (unsorted.length > 0) {
                    document.getElementById('status').innerHTML = 
                        `Inserted ${currentVal}. Check if reset needed: cur.val (${curIndex >= 0 ? sorted[curIndex] : 0}) > head.val (${unsorted[0]})?`;
                } else {
                    document.getElementById('status').innerHTML = 
                        `Inserted ${currentVal}. No more elements.`;
                }
            } else if (phase === 'check') {
                const curVal = curIndex >= 0 ? sorted[curIndex] : 0;
                
                if (unsorted.length > 0 && curVal > unsorted[0]) {
                    // Need to reset
                    curIndex = -1;
                    resets++;
                    highlightCode(9);
                    document.getElementById('status').innerHTML = 
                        `cur.val (${curVal}) > head.val (${unsorted[0]}). Reset cur to parent.`;
                } else if (unsorted.length > 0) {
                    // Skip reset - optimization!
                    skips++;
                    skipHighlight = true;
                    showOptimization(`cur.val (${curVal}) â‰¤ head.val (${unsorted[0]}). No reset needed! Saved ${sorted.length - curIndex - 1} comparisons.`);
                    document.getElementById('status').innerHTML = 
                        `ğŸš€ Optimization: Skip reset! cur stays at position ${curIndex}`;
                }
                phase = 'find';
            }

            updateStats();
            renderList();
        }

        function reset() {
            stopAuto();
            unsorted = [...initialList];
            sorted = [];
            curIndex = -1;
            lastInsertedVal = null;
            phase = 'find';
            comparisons = 0;
            resets = 0;
            skips = 0;
            skipHighlight = false;
            
            document.getElementById('stepBtn').disabled = false;
            document.getElementById('autoBtn').disabled = false;
            document.getElementById('status').innerHTML = 'Click "Step" or "Auto Run" to start optimized insertion sort';
            hideOptimization();
            highlightCode(null);
            updateStats();
            renderList();
        }

        function stopAuto() {
            if (autoInterval) {
                clearInterval(autoInterval);
                autoInterval = null;
                document.getElementById('autoBtn').textContent = 'Auto Run';
            }
        }

        document.getElementById('stepBtn').addEventListener('click', () => {
            stopAuto();
            executeStep();
        });

        document.getElementById('autoBtn').addEventListener('click', () => {
            if (autoInterval) {
                stopAuto();
            } else {
                autoInterval = setInterval(executeStep, 600);
                document.getElementById('autoBtn').textContent = 'â¸ Pause';
            }
        });

        document.getElementById('resetBtn').addEventListener('click', reset);

        // Initialize
        updateStats();
        renderList();
    </script>
</body>
</html>
