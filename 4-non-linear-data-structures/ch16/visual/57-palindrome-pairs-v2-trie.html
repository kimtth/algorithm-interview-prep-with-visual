<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Palindrome Pairs - Trie Solution</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Segoe UI', sans-serif; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); min-height: 100vh; padding: 20px; }
        .container { max-width: 1400px; margin: 0 auto; }
        h1 { text-align: center; color: white; margin-bottom: 10px; text-shadow: 2px 2px 4px rgba(0,0,0,0.3); }
        .subtitle { text-align: center; color: rgba(255,255,255,0.9); margin-bottom: 20px; font-size: 14px; }
        .controls { display: flex; justify-content: center; gap: 15px; margin-bottom: 20px; flex-wrap: wrap; }
        button { background: white; color: #667eea; border: none; padding: 10px 25px; border-radius: 25px; cursor: pointer; font-weight: 600; transition: all 0.3s; }
        button:hover { transform: scale(1.05); box-shadow: 0 5px 20px rgba(0,0,0,0.2); }
        button:disabled { opacity: 0.5; cursor: not-allowed; transform: none; }
        .main-content { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; }
        .panel { background: white; border-radius: 15px; padding: 20px; box-shadow: 0 10px 30px rgba(0,0,0,0.2); }
        .panel-title { font-size: 16px; font-weight: bold; color: #333; margin-bottom: 15px; padding-bottom: 10px; border-bottom: 2px solid #667eea; }
        .full-width { grid-column: 1 / -1; }
        .words-container { display: flex; gap: 15px; flex-wrap: wrap; justify-content: center; margin-bottom: 15px; }
        .word-item { background: #f5f7fa; padding: 10px 20px; border-radius: 10px; font-family: monospace; font-size: 16px; transition: all 0.3s; border: 2px solid transparent; }
        .word-item.active { background: #667eea; color: white; border-color: #764ba2; }
        .word-item.inserted { background: #e8f5e9; border-color: #4caf50; }
        .word-item.searching { background: #fff3e0; border-color: #ff9800; }
        .word-item.found { background: #e3f2fd; border-color: #2196f3; }
        #trie-svg { width: 100%; height: 400px; }
        .node circle { fill: #f5f7fa; stroke: #667eea; stroke-width: 2; }
        .node.active circle { fill: #667eea; stroke: #764ba2; }
        .node.palindrome circle { fill: #4caf50; stroke: #2e7d32; }
        .node.word-end circle { fill: #ff9800; stroke: #f57c00; }
        .node text { font-size: 12px; font-weight: bold; fill: #333; }
        .node.active text { fill: white; }
        .link { fill: none; stroke: #ccc; stroke-width: 2; }
        .link.active { stroke: #667eea; stroke-width: 3; }
        .results-container { display: flex; gap: 10px; flex-wrap: wrap; min-height: 50px; }
        .result-pair { background: linear-gradient(135deg, #667eea, #764ba2); color: white; padding: 8px 15px; border-radius: 20px; font-family: monospace; animation: fadeIn 0.3s; }
        @keyframes fadeIn { from { opacity: 0; transform: scale(0.8); } to { opacity: 1; transform: scale(1); } }
        .status-box { background: #f5f7fa; border-radius: 10px; padding: 15px; font-family: monospace; min-height: 60px; }
        .phase-indicator { display: flex; gap: 20px; justify-content: center; margin-bottom: 15px; }
        .phase { padding: 8px 20px; border-radius: 20px; background: #f5f7fa; color: #666; }
        .phase.active { background: #667eea; color: white; }
        .legend { display: flex; gap: 20px; justify-content: center; flex-wrap: wrap; margin-top: 15px; font-size: 12px; }
        .legend-item { display: flex; align-items: center; gap: 5px; }
        .legend-color { width: 16px; height: 16px; border-radius: 50%; border: 2px solid; }
        .logic-box { background: #f8f9fa; border-left: 4px solid #667eea; padding: 10px 15px; margin-top: 10px; font-size: 13px; }
    </style>
</head>
<body>
    <div class="container">
        <h1>üîç Palindrome Pairs - Trie Solution</h1>
        <p class="subtitle">O(n √ó k¬≤) using Trie with reverse word insertion and palindrome detection</p>

        <div class="controls">
            <button id="stepBtn">Step</button>
            <button id="autoBtn">Auto Run</button>
            <button id="resetBtn">Reset</button>
        </div>

        <div class="panel full-width">
            <div class="panel-title">üìù Words</div>
            <div class="phase-indicator">
                <div class="phase" id="phase-insert">Phase 1: Insert (Reversed)</div>
                <div class="phase" id="phase-search">Phase 2: Search</div>
            </div>
            <div class="words-container" id="words"></div>
        </div>

        <div class="main-content">
            <div class="panel">
                <div class="panel-title">üå≥ Trie Structure (Words inserted in reverse)</div>
                <svg id="trie-svg"></svg>
                <div class="legend">
                    <div class="legend-item"><div class="legend-color" style="background:#f5f7fa;border-color:#667eea;"></div>Node</div>
                    <div class="legend-item"><div class="legend-color" style="background:#667eea;border-color:#764ba2;"></div>Active</div>
                    <div class="legend-item"><div class="legend-color" style="background:#ff9800;border-color:#f57c00;"></div>Word End</div>
                    <div class="legend-item"><div class="legend-color" style="background:#4caf50;border-color:#2e7d32;"></div>Palindrome IDs</div>
                </div>
            </div>

            <div class="panel">
                <div class="panel-title">üìä Status</div>
                <div class="status-box" id="status">Click "Step" or "Auto Run" to start</div>
                <div class="logic-box" id="logic-box" style="display:none;"></div>
            </div>

            <div class="panel full-width">
                <div class="panel-title">‚úÖ Palindrome Pairs Found</div>
                <div class="results-container" id="results"></div>
            </div>
        </div>
    </div>

    <script>
        const words = ["abcd", "dcba", "lls", "s", "sssll"];
        let trie = { char: 'root', children: {}, wordId: -1, palindromeIds: [] };
        let step = 0;
        let phase = 'insert'; // 'insert' or 'search'
        let insertIndex = 0;
        let insertCharIndex = 0;
        let searchIndex = 0;
        let searchCharIndex = 0;
        let results = [];
        let autoInterval = null;
        let insertSubStep = 0; // 0: check palindrome, 1: insert char
        let searchSubStep = 0;
        let currentSearchWord = '';
        let searchNode = null;

        function isPalindrome(s) {
            return s === s.split('').reverse().join('');
        }

        function initWords() {
            const container = document.getElementById('words');
            container.innerHTML = words.map((w, i) => 
                `<div class="word-item" id="word-${i}">[${i}] "${w}"</div>`
            ).join('');
        }

        function renderTrie() {
            const svg = d3.select('#trie-svg');
            svg.selectAll('*').remove();

            const width = svg.node().getBoundingClientRect().width;
            const height = 400;
            const g = svg.append('g').attr('transform', 'translate(40, 40)');

            // Convert trie to hierarchy
            function buildHierarchy(node, char = 'root') {
                const result = { 
                    name: char, 
                    wordId: node.wordId, 
                    palindromeIds: node.palindromeIds || [],
                    active: node.active,
                    children: [] 
                };
                for (const [c, child] of Object.entries(node.children)) {
                    result.children.push(buildHierarchy(child, c));
                }
                return result;
            }

            const hierarchy = d3.hierarchy(buildHierarchy(trie));
            const treeLayout = d3.tree().size([width - 80, height - 80]);
            treeLayout(hierarchy);

            // Links
            g.selectAll('.link')
                .data(hierarchy.links())
                .enter()
                .append('path')
                .attr('class', d => 'link' + (d.target.data.active ? ' active' : ''))
                .attr('d', d3.linkVertical().x(d => d.x).y(d => d.y));

            // Nodes
            const nodes = g.selectAll('.node')
                .data(hierarchy.descendants())
                .enter()
                .append('g')
                .attr('class', d => {
                    let cls = 'node';
                    if (d.data.active) cls += ' active';
                    else if (d.data.wordId >= 0) cls += ' word-end';
                    else if (d.data.palindromeIds.length > 0) cls += ' palindrome';
                    return cls;
                })
                .attr('transform', d => `translate(${d.x}, ${d.y})`);

            nodes.append('circle').attr('r', 18);
            nodes.append('text')
                .attr('dy', 5)
                .attr('text-anchor', 'middle')
                .text(d => d.data.name);

            // Word ID labels
            nodes.filter(d => d.data.wordId >= 0)
                .append('text')
                .attr('dy', -25)
                .attr('text-anchor', 'middle')
                .attr('fill', '#ff9800')
                .attr('font-size', '10px')
                .text(d => `id:${d.data.wordId}`);

            // Palindrome IDs labels
            nodes.filter(d => d.data.palindromeIds.length > 0)
                .append('text')
                .attr('dy', 35)
                .attr('text-anchor', 'middle')
                .attr('fill', '#4caf50')
                .attr('font-size', '10px')
                .text(d => `P:[${d.data.palindromeIds.join(',')}]`);
        }

        function clearTrieActive() {
            function clear(node) {
                node.active = false;
                for (const child of Object.values(node.children)) {
                    clear(child);
                }
            }
            clear(trie);
        }

        function updateStatus(text) {
            document.getElementById('status').innerHTML = text;
        }

        function showLogic(text) {
            const box = document.getElementById('logic-box');
            box.style.display = 'block';
            box.innerHTML = text;
        }

        function hideLogic() {
            document.getElementById('logic-box').style.display = 'none';
        }

        function updatePhase() {
            document.getElementById('phase-insert').classList.toggle('active', phase === 'insert');
            document.getElementById('phase-search').classList.toggle('active', phase === 'search');
        }

        function executeStep() {
            if (phase === 'insert') {
                executeInsertStep();
            } else if (phase === 'search') {
                executeSearchStep();
            }
        }

        function executeInsertStep() {
            if (insertIndex >= words.length) {
                phase = 'search';
                updatePhase();
                searchNode = trie;
                updateStatus('Phase 1 complete. Starting Phase 2: Search for palindrome pairs.');
                hideLogic();
                return;
            }

            const word = words[insertIndex];
            const reversed = word.split('').reverse().join('');
            
            // Mark word as active
            document.querySelectorAll('.word-item').forEach(el => el.classList.remove('active'));
            document.getElementById(`word-${insertIndex}`).classList.add('active');
            document.getElementById(`word-${insertIndex}`).classList.add('inserted');

            if (insertCharIndex === 0 && insertSubStep === 0) {
                clearTrieActive();
                updateStatus(`Inserting word[${insertIndex}] = "${word}" as reversed: "${reversed}"`);
                showLogic(`Insert reversed word into Trie.<br>Check at each step if remaining prefix is a palindrome.`);
            }

            let node = trie;
            for (let i = 0; i < insertCharIndex; i++) {
                node = node.children[reversed[i]];
            }

            if (insertSubStep === 0) {
                // Check if remaining prefix is palindrome
                const remaining = word.substring(0, word.length - insertCharIndex);
                if (isPalindrome(remaining)) {
                    node.palindromeIds = node.palindromeIds || [];
                    if (!node.palindromeIds.includes(insertIndex)) {
                        node.palindromeIds.push(insertIndex);
                    }
                    updateStatus(`At position ${insertCharIndex}: remaining "${remaining}" is palindrome ‚Üí store word_id=${insertIndex}`);
                } else {
                    updateStatus(`At position ${insertCharIndex}: remaining "${remaining}" is NOT palindrome`);
                }
                node.active = true;
                insertSubStep = 1;
            } else {
                // Insert character
                if (insertCharIndex < reversed.length) {
                    const char = reversed[insertCharIndex];
                    if (!node.children[char]) {
                        node.children[char] = { char, children: {}, wordId: -1, palindromeIds: [] };
                    }
                    node.children[char].active = true;
                    updateStatus(`Insert character '${char}' at depth ${insertCharIndex + 1}`);
                    insertCharIndex++;
                    insertSubStep = 0;
                } else {
                    // Mark end of word
                    node.wordId = insertIndex;
                    updateStatus(`Mark end of word: word_id = ${insertIndex}`);
                    insertIndex++;
                    insertCharIndex = 0;
                    insertSubStep = 0;
                }
            }

            renderTrie();
        }

        function executeSearchStep() {
            if (searchIndex >= words.length) {
                updateStatus(`‚úÖ Search complete! Found ${results.length} palindrome pairs.`);
                document.getElementById('stepBtn').disabled = true;
                document.getElementById('autoBtn').disabled = true;
                stopAuto();
                return;
            }

            const word = words[searchIndex];
            
            document.querySelectorAll('.word-item').forEach(el => {
                el.classList.remove('active', 'searching');
            });
            document.getElementById(`word-${searchIndex}`).classList.add('searching');

            if (searchCharIndex === 0 && searchSubStep === 0) {
                clearTrieActive();
                searchNode = trie;
                trie.active = true;
                updateStatus(`Searching for pairs with word[${searchIndex}] = "${word}"`);
                showLogic(`<b>3 cases to check:</b><br>
                1) Exact match at end node<br>
                2) Remaining suffix is palindrome during traversal<br>
                3) Palindrome IDs stored at current node`);
            }

            if (searchCharIndex < word.length) {
                const char = word[searchCharIndex];
                
                // Case 2: Check if node has word_id and remaining is palindrome
                if (searchNode.wordId >= 0 && searchNode.wordId !== searchIndex) {
                    const remaining = word.substring(searchCharIndex);
                    if (isPalindrome(remaining)) {
                        const pair = [searchIndex, searchNode.wordId];
                        if (!results.some(r => r[0] === pair[0] && r[1] === pair[1])) {
                            results.push(pair);
                            addResult(pair);
                        }
                        updateStatus(`Case 2: word_id=${searchNode.wordId} found, remaining "${remaining}" is palindrome ‚Üí pair [${pair}]`);
                    }
                }

                if (!searchNode.children[char]) {
                    updateStatus(`Character '${char}' not found. Moving to next word.`);
                    searchIndex++;
                    searchCharIndex = 0;
                    searchNode = trie;
                    renderTrie();
                    return;
                }

                searchNode = searchNode.children[char];
                searchNode.active = true;
                updateStatus(`Traverse to '${char}' at depth ${searchCharIndex + 1}`);
                searchCharIndex++;
            } else {
                // Reached end of search word
                // Case 1: Exact match
                if (searchNode.wordId >= 0 && searchNode.wordId !== searchIndex) {
                    const pair = [searchIndex, searchNode.wordId];
                    if (!results.some(r => r[0] === pair[0] && r[1] === pair[1])) {
                        results.push(pair);
                        addResult(pair);
                    }
                    updateStatus(`Case 1: Exact match with word_id=${searchNode.wordId} ‚Üí pair [${pair}]`);
                }
                
                // Case 3: Palindrome IDs at current node
                if (searchNode.palindromeIds && searchNode.palindromeIds.length > 0) {
                    for (const pid of searchNode.palindromeIds) {
                        const pair = [searchIndex, pid];
                        if (!results.some(r => r[0] === pair[0] && r[1] === pair[1])) {
                            results.push(pair);
                            addResult(pair);
                            updateStatus(`Case 3: Palindrome ID ${pid} at node ‚Üí pair [${pair}]`);
                        }
                    }
                }

                searchIndex++;
                searchCharIndex = 0;
                searchNode = trie;
            }

            renderTrie();
        }

        function addResult(pair) {
            const container = document.getElementById('results');
            const combined = words[pair[0]] + words[pair[1]];
            container.innerHTML += `<div class="result-pair">[${pair[0]},${pair[1]}] "${combined}"</div>`;
        }

        function reset() {
            stopAuto();
            trie = { char: 'root', children: {}, wordId: -1, palindromeIds: [] };
            step = 0;
            phase = 'insert';
            insertIndex = 0;
            insertCharIndex = 0;
            insertSubStep = 0;
            searchIndex = 0;
            searchCharIndex = 0;
            searchSubStep = 0;
            searchNode = null;
            results = [];
            
            document.getElementById('results').innerHTML = '';
            document.querySelectorAll('.word-item').forEach(el => {
                el.classList.remove('active', 'inserted', 'searching', 'found');
            });
            document.getElementById('stepBtn').disabled = false;
            document.getElementById('autoBtn').disabled = false;
            hideLogic();
            updateStatus('Click "Step" or "Auto Run" to start');
            updatePhase();
            renderTrie();
        }

        function stopAuto() {
            if (autoInterval) {
                clearInterval(autoInterval);
                autoInterval = null;
                document.getElementById('autoBtn').textContent = 'Auto Run';
            }
        }

        document.getElementById('stepBtn').addEventListener('click', () => {
            stopAuto();
            executeStep();
        });

        document.getElementById('autoBtn').addEventListener('click', () => {
            if (autoInterval) {
                stopAuto();
            } else {
                autoInterval = setInterval(executeStep, 600);
                document.getElementById('autoBtn').textContent = '‚è∏ Pause';
            }
        });

        document.getElementById('resetBtn').addEventListener('click', reset);

        // Initialize
        initWords();
        updatePhase();
        renderTrie();
    </script>
</body>
</html>
